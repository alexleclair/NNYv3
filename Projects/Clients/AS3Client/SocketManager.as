package{	import flash.errors.*;	import flash.events.*;	import flash.net.Socket;	import flash.utils.Endian;	import dataTypes.*;	import flash.utils.ByteArray;	public class SocketManager	{		private var m_host:String = "";		private var m_port:int = 0;		private var m_socket:Socket;				protected var m_packetBuffer:ByteArray=new ByteArray();//Will hold every packet on the sending queue		protected var m_packetCount:int=0; //Will hold the amount of packets in the sending queue		protected var m_encapsulatedPacketsLength:int			=-1;					//Total length of the unreceived packets.		protected var m_encapsulatedPacketsCmdNbr:int			=0;					//Total amount of sub-commands(packets) of the unreceived packets.		protected var m_encapsulatedPacketsBuffer:ByteArray	=new ByteArray();	//Packets that are not 100% received				/*		 *	@params		host:String, port:int		 *	@desc		Calls connect() with the given host:port.		 *	@returns	void		 */		public function SocketManager(host:String, port:int)//Constructor		{			m_host=host;			m_port=port;			connect(m_host,m_port);			m_socket.endian=Endian.LITTLE_ENDIAN;			m_packetBuffer.endian=Endian.LITTLE_ENDIAN;		}				/*		 * @params:		host:String = null, port:int = 0		 * @desc: 		Connects to a server on the given host and port		 * @returns:	void		 */		private function connect(host:String = null, port:int = 0):void //Connect		{			m_socket = new Socket(host, port); //Calling the Socket class.			//Adding handlers			m_socket.addEventListener(Event.CLOSE, closeHandler);			m_socket.addEventListener(Event.CONNECT, connectHandler);			m_socket.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);			m_socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			m_socket.addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);		}				/*		 *	@params		packet:ByteArray		 *	@desc		Sends the given packet to the connected socket.		 *	@returns	void		 */		protected function sendData(packet:ByteArray)		{			m_socket.writeBytes(packet);		}						/*		 *	@params		cmdid:int, ...		 *	@desc		Prepares a packet and puts it into a buffer for sendPackets();		 *	@returns	void		 */		public function preparePacket(cmdid:int, ... rest):void		{			var packet:ByteArray=new ByteArray();			packet.endian=Endian.LITTLE_ENDIAN;			packet.writeShort(cmdid);			var len:int=rest.length;			for(var i:uint=0; i<len; ++i)			{				if(rest[i] is Number)					packet.writeUnsignedInt(rest[i]); //Treating numbers as WORDS.				else if(rest[i] is Short)					packet.writeShort(rest[i].valueOf()); //Short				else if(rest[i] is Boolean)					packet.writeBoolean(rest[i]);				else //Treating it as a STRING.				{					packet.writeUnsignedInt(rest[i].toString().length);					packet.writeMultiByte(rest[i],"US-ASCII");				}			}			m_packetBuffer.writeBytes(packet);			++m_packetCount;		}				/*		 *	@params		cmdid:int, ...		 *	@desc		Prepares a packet and puts it into a buffer for sendPackets();		 *	@returns	void		 */		public function sendPackets():void		{			if(m_packetBuffer.length == 0)			   return;			var packets:ByteArray = new ByteArray();		//Creating the BA Buffer...			packets.endian=Endian.LITTLE_ENDIAN;			packets.writeByte(0x7E); //Packet begin			packets.writeUnsignedInt(m_packetBuffer.length);//The length			//packets.writeByte(m_packetCount);//How many sub-packets in this packet			packets.writeBytes(m_packetBuffer);//Write the packets			m_packetBuffer= new ByteArray(); //Clearing the packetBuffer			m_packetCount=0;		//Resetting the packetCount variable			sendData(packets);			trace("sendPackets() called");		}				/************************************************************************//*		 *	@params		packet:ByteArray		 *	@desc		Takes care of the received packet. Makes sure it is complete and if so, sends it to handlePacket();		 *	@returns	void		 */		protected function onSocketData(packet:ByteArray):void		{			packet.endian=Endian.LITTLE_ENDIAN;			if(packet.length == 0)return;			var baToBeHandled:ByteArray=new ByteArray();			if(m_encapsulatedPacketsLength != -1)			{				trace('Incomplete capsule, just got some more of its contents');				//Handling buffered packets + received sub-packets				m_encapsulatedPacketsBuffer.writeBytes(packet);				m_encapsulatedPacketsBuffer.position=6; //Resetting the position to the first CMDID				if(m_encapsulatedPacketsLength <= m_encapsulatedPacketsBuffer.bytesAvailable)//The packet is 100% received.				{					trace("Packet complete! Current:"+m_encapsulatedPacketsBuffer.bytesAvailable+"\tTotal:"+m_encapsulatedPacketsLength);					m_encapsulatedPacketsBuffer.readBytes(baToBeHandled,m_encapsulatedPacketsBuffer.position,m_encapsulatedPacketsLength);					m_encapsulatedPacketsLength=-1; //Resetting the member variable m_encapsulatedPacketsLength.					baToBeHandled.position=0; //Setting the position to 0, so that the whole packet gets read.					handlePackets(baToBeHandled);			//Letting handlePacket do the dirty work for us :).					baToBeHandled=new ByteArray();					if(m_encapsulatedPacketsBuffer.bytesAvailable !=0)					{					m_encapsulatedPacketsBuffer.readBytes(baToBeHandled,m_encapsulatedPacketsBuffer.position,m_encapsulatedPacketsBuffer.bytesAvailable);					baToBeHandled.position=0;					onSocketData(baToBeHandled);					}				}			}			else	//New capsule.			{				trace('New capsule: '+packet.length);				var packetStart:int = packet.readByte(); //0x7E				var capsuleLength:uint = packet.readUnsignedInt();				trace(packetStart+" "+capsuleLength);				if(capsuleLength <= packet.bytesAvailable)//The packet is 100% received.				{					trace('Complete capsule, going on with handlePackets()');					m_encapsulatedPacketsLength=-1; //Resetting the member variable m_encapsulatedPacketsLength.					baToBeHandled=new ByteArray();					baToBeHandled.endian=Endian.LITTLE_ENDIAN;					packet.readBytes(baToBeHandled,0,capsuleLength);					baToBeHandled.position=0;					handlePackets(baToBeHandled);			//Letting handlePacket do the dirty work for us :).					baToBeHandled=new ByteArray();					if(packet.bytesAvailable != 0)					{						trace(packet.position+"<-"+packet.bytesAvailable);						packet.readBytes(baToBeHandled,packet.position,packet.bytesAvailable);						trace(packet.position+"<-"+packet.bytesAvailable);						baToBeHandled.position=0;						trace(baToBeHandled.length);						onSocketData(baToBeHandled);					}				}				else				{					trace('The capsule is incomplete, waiting for some more data.');					m_encapsulatedPacketsLength=capsuleLength;					m_encapsulatedPacketsBuffer=new ByteArray();					m_encapsulatedPacketsBuffer.writeBytes(packet); 				}			}		}						/********************************		 *								*		 *	Handlers / EventListeners	*		 *								*		 ********************************/		 //private methods. These should NOT be overwritten!		 protected function closeHandler(e:Event):void		 {			 trace('[socketManager] Connection closed.'+e);			 onSocketClose();		 }		 protected function connectHandler(e:Event):void		 {			trace('[socketManager] Connection opened. Connected:'+m_socket.connected+'. '+e);			m_socket.endian = Endian.BIG_ENDIAN; 			onSocketConnect(); 		 }		 protected function ioErrorHandler(e:IOErrorEvent):void		 {			 trace('[socketManager] I/O Error.'+e);			 onIoError();		 }		 protected function securityErrorHandler(e:SecurityErrorEvent):void		 {			 trace('[socketManager] Security Error.'+e);			 onSecurityError();		 }		 private function socketDataHandler(e:ProgressEvent):void		 {			var ba:ByteArray = new ByteArray(); //Will hold wthe data coming from the socket.			m_socket.readBytes(ba,0,m_socket.bytesAvailable); //Reading the byteArray (from the socket) into ba.			onSocketData(ba); //Passing ba to the onSocketData method.		 }		 		 //Empty methods that will be overwritten.		 protected function onSocketClose():void		 {			 		 }		 protected function onSocketConnect():void		 {					 }		 protected function onIoError():void		 {			 		 }		 protected function onSecurityError():void		 {			 		 }		 protected function handlePackets(packet:ByteArray)		 {			 		 }	}}